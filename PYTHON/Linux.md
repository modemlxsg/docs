#  《The Linux Command Line》

## 01、什么是shell

一说到命令行，我们真正指的是 **shell**。shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。“bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。

当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。 如果我们浏览一下桌面菜单，可能会找到一个。虽然在菜单里它可能都 被简单地称为 “**terminal**”，但是 KDE 用的是 konsole , 而 GNOME 则使用 gnome-terminal。 还有其他一些终端仿真器可供 Linux 使用，但基本上，它们都完成同样的事情， 让我们能访问 shell。也许，你可能会因为附加的一系列花俏功能而喜欢上某个终端。

如果提示符的最后一个字符是“**#**”, 而不是“**$**”, 那么这个终端会话就有超级用户权限。 这意味着，我们要么是以 root 用户的身份登录，要么是我们选择的终端仿真器提供超级用户（管理员）权限。

 如果你按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标**中键**， 这些文本就被粘贴到光标所在的位置。



## 02、文件系统中跳转

- **pwd** — 打印出当前工作目录名
- **cd** — 更改目录
- **ls** — 列出目录内容

**绝对路径**开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。 例如，你的系统中有一个目录，大多数系统程序都安装在这个目录下。这个目录的 路径名是 `/usr/bin`。它意味着从根目录（用开头的”/”表示）开始，有一个叫 “usr” 的 目录包含了目录 “bin”。

绝对路径从根目录开始，直到它的目的地，而**相对路径**开始于工作目录。 为了做到这个（用相对路径表示）， 我们在文件系统树中用一对特殊符号来表示相对位置。 这对特殊符号是 “.” (点) 和 “..” (点点)。

| 快捷键        | 运行结果                                                     |
| :------------ | :----------------------------------------------------------- |
| cd            | 更改工作目录到你的家目录。                                   |
| cd -          | 更改工作目录到先前的工作目录。                               |
| cd ~user_name | 更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。 |

关于文件名的重要规则

1. 以 “.” 字符开头的文件名是**隐藏文件**。这仅表示，ls 命令不能列出它们， 用 `ls -a` 命令就可以了。当你创建帐号后，几个配置帐号的隐藏文件被放置在 你的家目录下。稍后，我们会仔细研究一些隐藏文件，来定制你的系统环境。 另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。
2. 文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。
3. Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何名字 来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统， 不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。
4. 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与 词间的空格，用下划线字符来代替。过些时候，你会感激自己这样做。



## 03、探究操作系统

- **ls** — 列出目录内容

- **file** — 确定文件类型
- **less** — 浏览文件内容



### ls

| 选项 | 长选项           | 描述                                                         |
| :--- | :--------------- | :----------------------------------------------------------- |
| -a   | --all            | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d   | --directory      | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 <br />把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F   | --classify       | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h   | --human-readable | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l   |                  | 以长格式显示结果。                                           |
| -r   | --reverse        | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S   |                  | 命令输出结果按照文件大小来排序。                             |
| -t   |                  | 按照修改时间来排序。                                         |



### file

随着探究操作系统的进行，知道文件包含的内容是很有用的。我们将用 file 命令来确定文件的类型。我们之前讨论过， 在 Linux 系统中，并不要求文件名来反映文件的内容。然而，一个类似 “picture.jpg” 的文件名，我们会期望它包含 JPEG 压缩图像，但 Linux 却不这样要求它。可以这样调用 file 命令：`file filename`

```sh
[me@linuxbox ~]$ file picture.jpg
picture.jpg: JPEG image data, JFIF standard 1.01
```

有许多种类型的文件。事实上，在类 Unix 操作系统中比如说 Linux 中，有个普遍的观念就是“**一切皆文件**”。 随着课程的进行，我们将会明白这句话是多么的正确。



### less

| 命令               | 行为                                                     |
| :----------------- | :------------------------------------------------------- |
| Page UP or b       | 向上翻滚一页                                             |
| Page Down or space | 向下翻滚一页                                             |
| UP Arrow           | 向上翻滚一行                                             |
| Down Arrow         | 向下翻滚一行                                             |
| G                  | 移动到最后一行                                           |
| 1G or g            | 移动到开头一行                                           |
| /charaters         | 向前查找指定的字符串                                     |
| n                  | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h                  | 显示帮助屏幕                                             |
| q                  | 退出 less 程序                                           |



### linux目录

| 目录           | 评论                                                         |
| :------------- | :----------------------------------------------------------- |
| /              | 根目录，万物起源。                                           |
| /bin           | 包含系统启动和运行所必须的二进制程序。                       |
| /boot          | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 |
| /dev           | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc           | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 |
| /home          | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。     |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 |
| /usr           | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序。                                       |
| /usr/share     | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |



### 符号链接

在我们到处查看时，我们可能会看到一个目录，列出像这样的一条信息：

```sh
lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so
```

注意看，为何这条信息第一个字符是“l”，并且有两个文件名呢？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink ）。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。虽然这种特性的意义并不明显，但它真的很有用。

描绘一下这样的情景：一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是“foo”经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个“foo”版本。 这会导致另一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。

符号链接避免了这种情况。比方说，我们安装了文件 “foo” 的 2.6 版本，它的 文件名是 “foo-2.6”，然后创建了叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。 这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。 现在，每个人都很高兴。依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。 当升级到 “foo-2.7” 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。 假想 “foo-2.7” 有个错误（该死的开发者！），那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。

在上面列出的目录（来自于 Fedora 的 /lib 目录）展示了一个叫做 “libc.so.6” 的符号链接，这个符号链接指向一个 叫做 “libc-2.6.so” 的共享库文件。这意味着，寻找文件 “libc.so.6” 的程序，实际上得到是文件 “libc-2.6.so”。 在下一章节，我们将学习如何建立符号链接。



## 04、操作文件和目录

- **cp** — 复制文件和目录
- **mv** — 移动/重命名文件和目录
- **mkdir** — 创建目录
- **rm** — 删除文件和目录
- **ln** — 创建硬链接和符号链接



### 通配符

| 通配符        | 意义                               |
| :------------ | :--------------------------------- |
| *             | 匹配任意多个字符（包括零个或一个） |
| ?             | 匹配任意一个字符（不包括零个）     |
| [characters]  | 匹配任意一个属于字符集中的字符     |
| [!characters] | 匹配任意一个不是字符集中的字符     |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |

| [:alnum:] | 匹配任意一个字母或数字 |
| --------- | ---------------------- |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper:] | 匹配任意一个大写字母   |

| 模式                   | 匹配对象                                                  |
| :--------------------- | :-------------------------------------------------------- |
| *                      | 所有文件                                                  |
| g*                     | 文件名以“g”开头的文件                                     |
| b*.txt                 | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件 |
| Data???                | 以“Data”开头，其后紧接着3个字符的文件                     |
| [abc]*                 | 文件名以"a","b",或"c"开头的文件                           |
| BACKUP.[0-9][0-9][0-9] | 以"BACKUP."开头，并紧接着3个数字的文件                    |
| [[:upper:]]*           | 以大写字母开头的文件                                      |
| [![:digit:]]*          | 不以数字开头的文件                                        |
| *[[:lower:]123]        | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件    |



### mkdir - 创建目录

```sh
mkdir dir1 dir2 dir3
```

会创建三个目录，名为 dir1, dir2, dir3





### cp - 复制文件和目录

```sh
cp item1 item2
```

| 选项              | 意义                                                         |
| :---------------- | :----------------------------------------------------------- |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常，副本具有用户所操作文件的默认属性。 |
| -i, --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息                                       |

| 命令                | 运行结果                                                     |
| :------------------ | :----------------------------------------------------------- |
| cp file1 file2      | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。 |
| cp -i file1 file2   | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 |
| cp dir1/* dir2      | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 |
| cp -r dir1 dir2     | 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。 |



### mv - 移动和重命名文件

mv 命令可以执行**文件移动**和**文件命名**任务

```sh
mv item1 item2
```

把文件或目录 “item1” 移动或重命名为 “item2”



|                  |                                                              |
| ---------------- | ------------------------------------------------------------ |
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 **如果不指定这个选项，mv 命令会默认重写文件内容。** |
| -u --update      | 当把文件从一个目录移动另一个目录时，只是移动不存在的文件，<br /> 或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose     | 当操作 mv 命令时，显示翔实的操作信息。                       |

|                     |                                                              |
| ------------------- | ------------------------------------------------------------ |
| mv file1 file2      | 移动 file1 到 file2。**如果 file2 存在，它的内容会被 file1 的内容重写。** <br /> 如果 file2 不存在，则创建 file2。 **这两种情况下，file1 都不再存在。** |
| mv -i file1 file2   | 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。 |
| mv file1 file2 dir1 | 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。      |
| mv dir1 dir2        | 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，<br />同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。 |



### rm - 删除文件和目录

| 选项              | 意义                                                         |
| :---------------- | :----------------------------------------------------------- |
| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 **如果不指定这个选项，rm 会默默地删除文件** |
| -r, --recursive   | 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 |
| -f, --force       | 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。 |
| -v, --verbose     | 在执行 rm 命令时，显示翔实的操作信息。                       |

| 命令              | 运行结果                                                     |
| :---------------- | :----------------------------------------------------------- |
| rm file1          | 默默地删除文件                                               |
| rm -i file1       | 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。 |
| rm -r file1 dir1  | 删除文件 file1, 目录 dir1，及 dir1 中的内容。                |
| rm -rf file1 dir1 | 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。 |



### ln — 创建链接

ln 命令既可创建硬链接，也可以创建符号链接。可以用其中一种方法来使用它：

```sh
ln file link # 创建硬链接
ln -s item link # 创建符号链接，”item” 可以是一个文件或是一个目录。
```

与更加现代的符号链接相比，硬链接是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接， 这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。 硬链接有两个重要局限性：

1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。
2. 一个硬链接不能关联一个目录。

一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录 内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配）， 直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时 会遇到它们，但现在实际中更喜欢使用符号链接，下一步我们会讨论符号链接。

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面， 它们和 Windows 的快捷方式差不多，当然，符号链接早于 Windows 的快捷方式 很多年;-)

一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。



## 05、使用命令

type – 说明怎样解释一个命令名

which – 显示会执行哪个可执行程序

man – 显示命令手册页

apropos – 显示一系列适合的命令

info – 显示命令 info

whatis – 显示一个命令的简洁描述

alias – 创建命令别名



## 06、重定向

- cat － 连接文件
- sort － 排序文本行
- uniq － 报道或省略重复行
- grep － 打印匹配行
- wc － 打印文件中换行符，字，和字节个数
- head － 输出文件第一部分
- tail - 输出文件最后一部分
- tee - 从标准输入读取数据，并同时写到标准输出和文件



### 标准输入、输出和错误

到目前为止，我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。 第一，程序运行结果；这是说，程序要完成的功能。第二，我们得到状态和错误信息， 这些告诉我们程序进展。如果我们观察一个命令，例如 ls，会看到它的运行结果和错误信息 显示在屏幕上。

与 Unix 主题“任何东西都是一个文件”保持一致，像 ls这样的程序实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。

I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕， 但是通过 I/O 重定向，我们可以做出改变。



### 标准输出重定向

I/O 重定向允许我们来重定义标准输出的地点。我们使用 “**>**” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 `ls-output.txt` 中去， 由文件代替屏幕。

```sh 
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt
```

这里，我们创建了一个长长的目录/usr/bin 列表，并且输送程序运行结果到文件 ls-output.txt 中。 我们检查一下重定向的命令输出结果：

```sh
[me@linuxbox ~]$ ls -l ls-output.txt
-rw-rw-r-- 1   me   me    167878 2008-02-01 15:07 ls-output.txt
```

简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是 创建一个新的空文件。

```sh
[me@linuxbox ~]$ > ls-output.txt
```

所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”**>>**“重定向符，像这样：

```sh
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
```

使用”>>“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。



### 标准错误重定向

标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 **三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2**。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：

```sh
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```

文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。



### 重定向标准输出和错误到同一个文件

有时我们希望将一个命令的所有输出保存到一个文件。为此，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个是传统的方法， 在旧版本 shell 中也有效：

```sh
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```

使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法`2>&1`。

注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，

现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。

```sh
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

在这个例子里面，我们使用单单一个表示法 `&>` 来重定向标准输出和错误到文件 ls-output.txt。



### 处理不需要的输出

有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”`/dev/null`”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：

```sh
[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
```



### 标准输入重定向



### cat － 连接文件

cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:

```sh
cat [file]
```

在大多数情况下，你可以认为 cat 命令相似于 DOS 中的 TYPE 命令。你可以使用 cat 来显示 文件而没有分页，例如：

```sh
[me@linuxbox ~]$ cat ls-output.txt
```

将会显示文件 ls-output.txt 的内容。cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个 大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离）， 我们想把它们连起来。如果文件命名为：`movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099`

```sh
cat movie.mpeg.0* > movie.mpeg
```

因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排

如果 cat 没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘， 它正在等待我们输入数据！试试这个：

```sh
[me@linuxbox ~]$ cat
The quick brown fox jumped over the lazy dog.
```

下一步，输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾

由于没有文件名参数，cat 复制标准输入到标准输出，所以我们看到文本行重复出现。 我们可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做”lazy_dog.txt” 的文件，这个文件包含例子中的文本。我们这样做：

```sh
[me@linuxbox ~]$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我们 实现了世界上最低能的文字处理器！看一下运行结果，我们使用 cat 来复制文件内容到 标准输出：

```sh
[me@linuxbox ~]$ cat lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

现在我们知道 cat 怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：

```sh
[me@linuxbox ~]$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

使用“**<**”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.txt。我们看到结果 和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，不是特别有意义， 但它是用来说明把一个文件作为标准输入源。有其他的命令更好地利用了标准输入，我们不久将会看到。



### 管道线

命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”**|**”（竖杠），**一个命令的标准输出可以通过管道送至另一个命令的标准输入**：

```sh
command1 | command2
```

为了全面地说明这个命令，我们需要一些命令。是否记得我们说过，我们已经知道有一个 命令接受标准输入？它是 less 命令。我们用 less 来一页一页地显示任何命令的输出，命令把 它的运行结果输送到标准输出：

```sh
[me@linuxbox ~]$ ls -l /usr/bin | less
```





### 过滤器

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：

```sh
[me@linuxbox ~]$ ls /bin /usr/bin | sort | less
```

因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。



### uniq - 报道或忽略重复行

uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序 列表（详情查看 uniq 手册页），默认情况下，从数据列表中删除任何重复行。所以，为了确信 我们的列表中不包含重复句子（这是说，出现在目录/bin 和/usr/bin 中重名的程序），我们添加 uniq 到我们的管道线中：

```sh
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
```





### wc － 打印行数、字数和字节数

wc（字计数）命令是用来显示文件所包含的行数、字数和字节数。例如：

```sh
[me@linuxbox ~]$ wc ls-output.txt
7902 64566 503634 ls-output.txt
```

在这个例子中，wc 打印出来三个数字：包含在文件 ls-output.txt 中的**行数，单词数和字节数**， 正如我们先前的命令，如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能 报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：

```sh
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```



### grep － 打印匹配行

grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：

```sh
grep pattern [file...]
```

当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。grep 能够匹配的模式可以 很复杂，但是现在我们把注意力集中在简单文本匹配上面。在后面的章节中，我们将会研究 高级模式，叫做正则表达式。

比如说，我们想在我们的程序列表中，找到文件名中包含单词”zip”的所有文件。这样一个搜索， 可能让我们了解系统中的一些程序与文件压缩有关系。这样做：

```sh
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```

grep 有一些方便的选项：”**-i**”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”**-v**”选项会告诉 grep 只打印不匹配的行。



### head / tail － 打印文件开头部分/结尾部分

有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”**-n**”选项来调整命令打印的行数。

tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在 一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages 可能包含安全信息。

使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。



### tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件

为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个”tee”，安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：

```sh
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```



## 07、从 shell 眼中看世界

echo － 显示一行文本

每当你输入一个命令并按下 enter 键，bash 会在执行你的命令之前对输入 的字符完成几个步骤的处理。我们已经见过几个例子：例如一个简单的字符序列”*”, 对 shell 来说有着多么丰富的涵义。这背后的的过程叫做（字符）展开。通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。为了说明这一点 ，让我们看一看 echo 命令。echo 是一个 shell 内建命令，可以完成非常简单的任务。 它将它的文本参数打印到标准输出中。

``` sh
[me@linuxbox ~]$ echo this is a test
this is a test
```



### 路径名展开

通配符所依赖的工作机制叫做路径名展开。

```sh
[me@linuxbox ~]$ ls
Desktop   ls-output.txt   Pictures   Templates
```

我们能够执行以下的展开：

```
[me@linuxbox ~]$ echo D*
Desktop  Documents

[me@linuxbox ~]$ echo *s
Documents Pictures Templates Videos

[me@linuxbox ~]$ echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos
```



### 波浪线展开

可能你从我们对 cd 命令的介绍中回想起来，波浪线字符(“~”)有特殊的含义。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录：

```sh
[me@linuxbox ~]$ echo ~
/home/me
```



### 算术表达式展开

shell 在展开中执行算数表达式。这允许我们把 shell 提示当作计算器来使用：

```sh
[me@linuxbox ~]$ echo $((2 + 2))
4

# 算术表达式展开使用这种格式：
$((expression))
```

| 操作符 | 说明                                                       |
| :----- | :--------------------------------------------------------- |
| +      | 加                                                         |
| -      | 减                                                         |
| *      | 乘                                                         |
| /      | 除（但是记住，因为展开只是支持整数除法，所以结果是整数。） |
| %      | 取余，只是简单的意味着，“余数”                             |
| **     | 取幂                                                       |



### 花括号展开

可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：

```
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能 嵌入空白字符。这个例子中使用了一个整数区间：

```
[me@linuxbox ~]$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
```

花括号展开可以嵌套：

```sh
[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
```

那么这对什么有好处呢？最常见的应用是，创建一系列的文件或目录列表。



### 参数展开

在这一章我们将会简单介绍参数展开，但会在后续章节中进行详细讨论。这个特性在 shell 脚本中比直接在命令行中更有用。 它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。例如，叫做”USER”的变量包含你的 用户名。可以这样做来调用参数，并查看 USER 中的内容，：

```sh
[me@linuxbox ~]$ echo $USER
me
```



### 命令替换

命令替换允许我们把一个命令的输出作为一个展开模式来使用：

```sh
[me@linuxbox ~]$ echo $(ls)
Desktop Documents ls-output.txt Music Pictures Public Templates
Videos
```

我最喜欢用的一行命令是像这样的：

```
[me@linuxbox ~]$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

这里我们把 which cp 的执行结果作为一个参数传递给 ls 命令，因此可以在不知道 cp 命令 完整路径名的情况下得到它的文件属性列表。我们不只限制于简单命令。也可以使用整个管道线 （只展示部分输出）：

```sh
[me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)
/usr/bin/bunzip2:     symbolic link to `bzip2'
....
```



### 引用

```sh
[me@linuxbox ~]$ echo this is a    test
this is a test
```

```sh
[me@linuxbox ~]$ echo The total is $100.00
The total is 00.00
```

在第一个例子中，shell 利用单词分割删除掉 echo 命令的参数列表中多余的空格。在第二个例子中， 参数展开把 `$1` 的值替换为一个空字符串，因为 `1` 是没有定义的变量。shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。



### 双引号

我们将要看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。 有几个例外： $，\ (反斜杠），和 `（倒引号）。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说我们是不幸的 名为 *two words.txt* 文件的受害者。如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：

```sh
[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```

使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。

```
[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv "two words.txt" two_words.txt
```



### 单引号

如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：

```sh
[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt   {a,b} foo 4 me
[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```

正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。



### 转义字符

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。

```sh
[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
The balance for user me is: $5.00
```

| 转义序列 | 含义                                   |
| -------- | -------------------------------------- |
| \a       | 响铃（”警告”－导致计算机嘟嘟响）       |
| \b       | 退格符                                 |
| \n       | 新的一行。在类 Unix 系统中，产生换行。 |
| \r       | 回车符                                 |
| \t       | 制表符                                 |



## 08、键盘高级操作技巧

- clear － 清空屏幕
- history － 显示历史列表内容



### 命令行编辑

Bash 使用了一个名为 Readline 的库（共享的例程集合，可以被不同的程序使用）， 来实现命令行编辑。我们已经看到一些例子。我们知道，例如，箭头按键可以移动光标， 此外还有许多特性。想想这些额外的工具，我们可以在工作中使用。学会所有的特性 并不重要，但许多特性非常有帮助。选择自己需要的特性。



### 移动光标

| 按键   | 行动                                                   |
| :----- | :----------------------------------------------------- |
| Ctrl-a | 移动光标到行首。                                       |
| Ctrl-e | 移动光标到行尾。                                       |
| Ctrl-f | 光标前移一个字符；和右箭头作用一样。                   |
| Ctrl-b | 光标后移一个字符；和左箭头作用一样。                   |
| Alt-f  | 光标前移一个字。                                       |
| Alt-b  | 光标后移一个字。                                       |
| Ctrl-l | 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。 |



### 修改文本

| 按键   | 行动                                     |
| :----- | :--------------------------------------- |
| Ctrl-d | 删除光标位置的字符。                     |
| Ctrl-t | 光标位置的字符和光标前面的字符互换位置。 |
| Alt-t  | 光标位置的字和其前面的字互换位置。       |
| Alt-l  | 把从光标位置到字尾的字符转换成小写字母。 |
| Alt-u  | 把从光标位置到字尾的字符转换成大写字母。 |



### 剪切和粘贴文本

Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。 剪切下来的本文被存储在一个叫做剪切环(kill-ring)的缓冲区中。

| 按键          | 行动                                                         |
| :------------ | :----------------------------------------------------------- |
| Ctrl-k        | 剪切从光标位置到行尾的文本。                                 |
| Ctrl-u        | 剪切从光标位置到行首的文本。                                 |
| Alt-d         | 剪切从光标位置到词尾的文本。                                 |
| Alt-Backspace | 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 |
| Ctrl-y        | 把剪切环中的文本粘贴到光标位置。                             |



### 自动补全

shell 能帮助你的另一种方式是通过一种叫做自动补全的机制。当你敲入一个命令时， 按下 tab 键，自动补全就会发生。

| 按键  | 行动                                                         |
| :---- | :----------------------------------------------------------- |
| Alt-? | 显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。 |
| Alt-* | 插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。 |



### 利用历史命令

正如我们在第二章中讨论到的，bash 维护着一个已经执行过的命令的历史列表。这个命令列表 被保存在你家目录下，一个叫做 .bash_history 的文件里。这个 history 工具是个有用资源， 因为它可以减少你敲键盘的次数，尤其当和命令行编辑联系起来时。



### 搜索历史命令

```sh
[me@linuxbox ~]$ history | less
```



在默认情况下，bash 会存储你所输入的最后 500 个命令。在随后的章节里，我们会知道 怎样调整这个数值。比方说我们想在自己曾经用过的命令中，找出和/usr/bin这一目录相关的。那么我们就可以这样做：

```sh
[me@linuxbox ~]$ history | grep /usr/bin
88  ls -l /usr/bin > ls-output.txt

# 数字 “88” 是这个命令在历史列表中的行号。我们可以使用另一种叫做 历史命令展开的方式，来调用“88”所代表的这一行命令：
[me@linuxbox ~]$ !88
```

bash 会把 “!88” 展开成为历史列表中88行的内容。还有其它的历史命令展开形式，我们一会儿 讨论它们。bash 也具有增量搜索历史列表的能力。意思是在字符输入的同时，bash 会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入 `Ctrl-r`来启动增量搜索， 接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。现在看看它的实际效果：

| 按键   | 行为                                                         |
| :----- | :----------------------------------------------------------- |
| Ctrl-p | 移动到上一个历史条目。类似于上箭头按键。                     |
| Ctrl-n | 移动到下一个历史条目。类似于下箭头按键。                     |
| Alt-<  | 移动到历史列表开头。                                         |
| Alt->  | 移动到历史列表结尾，即当前命令行。                           |
| Ctrl-r | 反向增量搜索。从当前命令行开始，向上增量搜索。               |
| Alt-p  | 反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter来执行搜索）。 |
| Alt-n  | 向前搜索，非增量。                                           |
| Ctrl-o | 执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。 |



### 历史命令展开

| 序列     | 行为                                                         |
| :------- | :----------------------------------------------------------- |
| !!       | 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 |
| !number  | 重复历史列表中第 number 行的命令。                           |
| !string  | 重复最近历史列表中，以这个字符串开头的命令。                 |
| !?string | 重复最近历史列表中，包含这个字符串的命令。                   |



## 09、权限

Unix 传统中的操作系统不同于那些 MS-DOS 传统中的系统，区别在于它们不仅是多任务系统，而且也是 多用户系统。这到底意味着什么？它意味着**多个用户可以在同一时间使用同一台计算机**。然而一个 典型的计算机可能只有一个键盘和一个监视器，但是它仍然可以被多个用户使用。例如，如果一台 计算机连接到一个网络或者因特网，那么远程用户通过 ssh（安全 shell）可以登录并操纵这台电脑。 事实上，远程用户也能运行图形界面应用程序，并且图形化的输出结果会出现在远端的显示器上。 X 窗口系统把这个作为基本设计理念的一部分，并支持这种功能。

**id** – 显示用户身份号

**chmod** – 更改文件模式

**umask** – 设置默认的文件权限

**su** – 以另一个用户的身份来运行 shell

**sudo** – 以另一个用户的身份来执行命令

**chown** – 更改文件所有者

**chgrp** – 更改文件组所有权

**passwd** – 更改用户密码



### 拥有者、组成员和其他人

```sh
[me@linuxbox ~]$ id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
```

正如我们能看到的，两个系统中用户的 uid 和 gid 号码是不同的。原因很简单，因为 Fedora 系统 从500开始进行普通用户帐户的编号，而 Ubuntu 从1000开始。我们也能看到 Ubuntu 的用户属于 更多的用户组。这和 Ubuntu 管理系统设备和服务权限的方式有关系。

那么这些信息来源于哪里呢？像 Linux 系统中的许多东西一样，来自一系列的文本文件。用户帐户 定义在`/etc/passwd` 文件里面，用户组定义在`/etc/group` 文件里面。当用户帐户和用户组创建以后， 这些文件随着文件`/etc/shadow` 的变动而修改，文件`/etc/shadow` 包含了关于用户密码的信息。 对于每个用户帐号，文件`/etc/passwd` 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录 和登录 shell。如果你查看一下文件`/etc/passwd` 和文件`/etc/group` 的内容，你会注意到除了普通 用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。



### 读取、写入和执行

对于文件和目录的访问权力是根据**读访问**、**写访问**和**执行访问**来定义的。如果我们看一下 ls 命令的输出结果，我们能得到一些线索，这是怎样实现的：

```sh
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt
```

列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到 的文件类型（还有其它的，不常见类型）：

| 属性 | 文件类型                                                     |
| :--- | :----------------------------------------------------------- |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器 |
| b    | 一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。 |

剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。

当设置文件模式后，r、w和x 模式属性对文件和目录会产生以下影响：

| 属性 | 文件                                                         | 目录                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| r    | 允许打开并读取文件内容。                                     | 允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。  |
| w    | 允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。 | 允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。 |
| x    | 允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。 | 允许进                                                       |

| 文件属性   | 含义                                                         |
| :--------- | :----------------------------------------------------------- |
| -rwx------ | 一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。 |
| -rw------- | 一个普通文件，对文件所有者来说可读可写。其他人无法访问。     |
| -rw-r--r-- | 一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。 |
| -rwxr-xr-x | 一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。 |
| -rw-rw---- | 一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。 |
| lrwxrwxrwx | 一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。 |
| drwxrwx--- | 一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。 |
| drwxr-x--- | 一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。 |



### chmod － 更改文件模式

更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才 能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或 符号表示法。首先我们讨论一下八进制数字表示法。

通过八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表展示了 我们所要表达的意思：

| Octal | Binary | File Mode |
| ----- | ------ | --------- |
| 0     | 000    | ---       |
| 1     | 001    | --x       |
| 2     | 010    | -w-       |
| 3     | 011    | -wx       |
| 4     | 100    | r--       |
| 5     | 101    | r-x       |
| 6     | 110    | rw-       |
| 7     | 111    | rwx       |

通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：

```sh
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw------- 1 me    me    0  2008-03-06 14:52 foo.txt
```

通过传递参数 “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有 权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (---)。



chmod 命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定 要影响的对象，如下所示：

|      |                                          |
| ---- | ---------------------------------------- |
| u    | "user"的简写，意思是文件或目录的所有者。 |
| g    | 用户组。                                 |
| o    | "others"的简写，意思是其他所有的人。     |
| a    | "all"的简写，是"u", "g"和“o”三者的联合。 |

如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。

权限由 “r”、“w”和 “x” 来指定。这里是一些符号表示法的实例：

| u+x       | 为文件所有者添加可执行权限。                                 |
| --------- | ------------------------------------------------------------ |
| u-x       | 删除文件所有者的可执行权限。                                 |
| +x        | 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。 |
| o-rw      | 除了文件所有者和用户组，删除其他人的读权限和写权限。         |
| go=rw     | 给文件所属的组和文件所属者/组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。 |
| u+x,go=rw | 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。 |

要注意”--recursive”选项： 它可以同时作用于文件和目录，所以它并不是如我们期望的那么有用处，因为我们很少希望文件和 目录拥有同样的权限。



### umask － 设置默认权限

```sh
[me@linuxbox ~]$ rm foo.txt
[me@linuxbox ~]$ umask 0000
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-rw- 1 me   me    0 2008-03-06 14:58 foo.txt
```

当掩码设置为0000（实质上是关掉它）之后，我们看到其他人能够读写文件。为了弄明白这是 怎么回事，我们需要看一下掩码的八进制形式。把掩码展开成二进制形式，然后与文件属性 相比较，看看有什么区别：

| Original file mode | --- rw- rw- rw- |
| ------------------ | --------------- |
| Mask               | 000 000 000 010 |
| Result             | --- rw- rw- r-- |

此刻先忽略掉开头的三个零（我们一会儿再讨论），注意掩码中若出现一个数字1，则 删除文件模式中和这个1在相同位置的属性，在这是指其他人的写权限。这就是掩码要完成的 任务。掩码的二进制形式中，出现数字1的位置，相应地关掉一个文件模式属性。看一下 掩码0022的作用：

| Original file mode | --- rw- rw- rw- |
| ------------------ | --------------- |
| Mask               | 000 000 010 010 |
| Result             | --- rw- r-- r-- |



### 更改身份

在不同的时候，我们会发现很有必要具有另一个用户的身份。经常地，我们想要得到超级 用户特权，来执行一些管理任务，但是也有可能”变为”另一个普通用户，比如说测试一个帐号。 有三种方式，可以拥有多重身份：

1. 注销系统并以其他用户身份重新登录系统。
2. 使用 su 命令。
3. 使用 sudo 命令。



在我们自己的 shell 会话中，su 命令允许你假定为另一个用户的身份，以这个用户的 ID 启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。sudo 命令允许一个管理员 设置一个叫做`/etc/sudoers` 的配置文件，并且定义了一些具体命令，在假定的身份下，特殊用户 可以执行这些命令。选择使用哪个命令，很大程度上是由你使用的 Linux 发行版来决定的。 你的发行版可能这两个命令都包含，但系统配置可能会偏袒其中之一。我们先介绍 su 命令。



### su － 以其他用户身份和组 ID 运行一个 shell

```sh
su [-[l]] [user]
```

如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：

```sh
[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]#
```

按下回车符之后，shell 提示我们输入超级用户的密码。如果密码输入正确，出现一个新的 shell 提示符， 这表明这个 shell 具有超级用户特权（提示符的末尾字符是”#”而不是”$”），并且当前工作目录是超级用户的家目录 （通常是/root）。一旦进入一个新的 shell，我们能执行超级用户所使用的命令。当工作完成后， 输入”exit”，则返回到原来的 shell:

以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：

```sh
su -c 'command'
```





### sudo － 以另一个用户身份执行命令

sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。 另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他/她自己的密码 来认证。比如说，例如，sudo 命令经过配置，允许我们运行一个虚构的备份程序，叫做”backup_script”， 这个程序要求超级用户权限。通过 sudo 命令，这个程序会像这样运行：

```sh
[me@linuxbox ~]$ sudo backup_script
Password:
System Backup Starting...
```

按下回车键之后，shell 提示我们输入我们的密码（不是超级用户的）。一旦认证完成，则执行 具体的命令。su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个 用户的 shell 运行环境。这意味者命令不必用单引号引起来。注意通过指定各种各样的选项，这 种行为可以被推翻。详细信息，阅读 sudo 手册页。

想知道 sudo 命令可以授予哪些权限，使用”-l”选项，列出所有权限：

```sh
[me@linuxbox ~]$ sudo -l
User me may run the following commands on this host:
(ALL) ALL
```



### chown － 更改文件所有者和用户组

```sh
chown [owner][:[group]] file...
```

| 参数      | 结果                                                         |
| :-------- | :----------------------------------------------------------- |
| bob       | 把文件所有者从当前属主更改为用户 bob。                       |
| bob:users | 把文件所有者改为用户 bob，文件用户组改为用户组 users。       |
| :admins   | 把文件用户组改为组 admins，文件所有者不变。                  |
| bob:      | 文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。 |



### chgrp － 更改用户组所有权

在旧版 Unix 系统中，chown 命令只能更改文件所有权，而不是用户组所有权。为了达到目的， 使用一个独立的命令，chgrp 来完成。除了限制多一点之外，chgrp 命令与 chown 命令使用起来很相似。



















## 10、进程

- ps – 报告当前进程快照
- top – 显示任务
- jobs – 列出活跃的任务
- bg – 把一个任务放到后台执行
- fg – 把一个任务放到前台执行
- kill – 给一个进程发送信号
- killall – 杀死指定名字的进程
- shutdown – 关机或重启系统



### 进程是怎样工作的

当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 `init` 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口(User Interface)。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。

在进程方案中，一个程序可以发动另一个程序被表述为一个父进程可以产生一个子进程。

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 或 `PID`。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。



### ps - 查看进程

```sh
[me@linuxbox ~]$ ps
PID TTY           TIME CMD
5198 pts/1    00:00:00 bash
10129 pts/1   00:00:00 ps
```

上例中，列出了两个进程，进程 5198 和进程 10129，各自代表命令 bash 和 ps。正如我们所看到的， 默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。为了得到更多信息， 我们需要加上一些选项，但是在这样做之前，我们先看一下 ps 命令运行结果的其它字段。 TTY 是 “Teletype”(直译电传打字机) 的简写，是指进程的控制终端。TTY足足显示了 Unix 的年代久远。TIME 字段表示 进程所消耗的 CPU 时间数量。正如我们所看到的，这两个进程使计算机工作起来很轻松。

如果给 ps 命令加上选项，我们可以得到更多关于系统运行状态的信息：

```sh
[me@linuxbox ~]$ ps x
PID TTY   STAT   TIME COMMAND
2799 ?    Ssl    0:00 /usr/libexec/bonobo-activation-server –ac
2820 ?    Sl     0:01 /usr/libexec/evolution-data-server-1.10 --

and many more...
```

加上 “**x**” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以看到我们所拥有的每个进程的信息。

输出结果中，新添加了一栏，标题为 STAT 。STAT 是 “state” 的简写，它揭示了进程当前状态：

| 状态 | 含义                                                         |
| :--- | :----------------------------------------------------------- |
| R    | 运行中。这意味着，进程正在运行或准备运行。                   |
| S    | 正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。 |
| D    | 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 |
| T    | 已停止. 已经指示进程停止运行。稍后介绍更多。                 |
| Z    | 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除） |
| <    | 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 |
| N    | 低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。 |

另一个流行的选项组合是 “**aux**”（不带开头的”-“字符）。这会给我们更多信息：

```sh
[me@linuxbox ~]$ ps aux
USER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     1   0.0   0.0    2136    644  ?     Ss     Mar05   0:31  init
root     2   0.0   0.0       0      0  ?     S&lt;     Mar05   0:00  [kt]

and many more...
```

这个选项组合，能够显示属于每个用户的进程信息。使用这个选项，可以唤醒 “BSD 风格” 的输出结果。 Linux 版本的 ps 命令，可以模拟几个不同 Unix 版本中的 ps 程序的行为。通过这些选项，我们得到 这些额外的列。

| 标题  | 含义                                             |
| :---- | :----------------------------------------------- |
| USER  | 用户 ID. 进程的所有者。                          |
| %CPU  | 以百分比表示的 CPU 使用率                        |
| %MEM  | 以百分比表示的内存使用率                         |
| VSZ   | 虚拟内存大小                                     |
| RSS   | 进程占用的物理内存的大小，以千字节为单位。       |
| START | 进程启动的时间。若它的值超过24小时，则用天表示。 |



### top - 动态查看进程

虽然 ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照。 为了看到更多动态的信息，我们使用 top 命令

top 程序以进程活动顺序显示连续更新的系统进程列表。（默认情况下，每三秒钟更新一次），”top”这个名字 来源于 top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。

```sh
top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombie
Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
Mem:   319496k total,   314860k used,   4636k free,   19392k buff
Swap:  875500k total,   149128k used,   726372k free,  114676k cach

 PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND
6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd
....
```

| 行号 | 字段          | 意义                                                         |
| :--- | :------------ | :----------------------------------------------------------- |
| 1    | top           | 程序名。                                                     |
|      | 14:59:20      | 当前时间。                                                   |
|      | up 6:30       | 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。 |
|      | 2 users       | 有两个用户登录系统。                                         |
|      | load average: | 加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。 |
| 2    | Tasks:        | 总结了进程数目和这些进程的各种状态。                         |
| 3    | Cpu(s):       | 这一行描述了 CPU 正在进行的活动的特性。                      |
|      | 0.7%us        | 0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。         |
|      | 1.0%sy        | 1.0%的 CPU 时间被用于系统（内核）进程。                      |
|      | 0.0%ni        | 0.0%的 CPU 时间被用于"nice"（低优先级）进程。                |
|      | 98.3%id       | 98.3%的 CPU 时间是空闲的。                                   |
|      | 0.0%wa        | 0.0%的 CPU 时间来等待 I/O。                                  |
| 4    | Mem:          | 展示物理内存的使用情况。                                     |
| 5    | Swap:         | 展示交换分区（虚拟内存）的使用情况。                         |

top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。



### 控制进程

现在我们可以看到和监测进程，让我们得到一些对它们的控制权。为了我们的实验，我们将使用 一个叫做 xlogo 的小程序，作为我们的实验品。这个 xlogo 程序是 X 窗口系统 （使图形界面显示在屏幕上的底层引擎）提供的示例程序，这个程序仅显示一个大小可调的 包含 X 标志的窗口。首先，我们需要知道测试的实验对象



#### 终止一个进程

在一个终端中，输入 `Ctrl-c`，中断一个程序



#### 把一个进程放置到后台(执行)

为了启动一个程序并让它立即在后台 运行，我们在程序命令之后，加上 **”&”**字符：

```sh
[me@linuxbox ~]$ xlogo &
[1] 28236
[me@linuxbox ~]$
```

这条信息是 shell 特性的一部分，叫做`任务控制 (job control)`。通过这条信息，shell 告诉我们，已经启动了 任务号(job number)为1（“［1］”），PID 为28236的程序。如果我们运行 ps 命令，可以看到我们的进程：

shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 `jobs` 命令，我们可以看到这个输出列表：

```sh
[me@linuxbox ~]$ jobs
[1]+ Running            xlogo &
```

结果显示我们有一个任务，编号为“1”，它正在运行，并且这个任务的命令是 xlogo ＆。



#### 进程返回到前台

一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。 为了让一个进程返回前台 (foreground)，这样使用 `fg` 命令：

```sh
[me@linuxbox ~]$ jobs
[1]+ Running        xlogo &
[me@linuxbox ~]$ fg %1
xlogo
```

fg 命令之后，跟随着一个百分号和任务序号（叫做 jobspec,如此处的%1）就可以了。如果我们只有一个后台任务，那么 jobspec(job specification) 是可有可无的。输入 Ctrl-c 来终止 xlogo 程序。



#### 挂起一个进程

有时候，我们想要停止一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动到后台。 输入 `Ctrl-z`，可以停止一个前台进程。让我们试一下。在命令提示符下，执行 xlogo 命令， 然后输入 Ctrl-z:

``` sh
[me@linuxbox ~]$ xlogo
[1]+ Stopped                 xlogo
[me@linuxbox ~]$
```

停止 xlogo 程序之后，通过调整 xlogo 的窗口大小，我们可以证实这个程序已经停止了。 它看起来像死掉了一样。使用 `fg` 命令，可以恢复程序到前台运行，或者用 `bg` 命令把程序移到后台。



### 信号

kill 命令被用来“杀死”程序。这样我们就可以终止需要杀死的程序。这里有一个例子：

```sh
[me@linuxbox ~]$ xlogo &
[1] 28401
[me@linuxbox ~]$ kill 28401
[1]+ Terminated               xlogo
```

首先，我们在后台启动 xlogo 程序。shell 打印出这个后台进程的 jobspec 和 PID。下一步，我们使用 kill 命令，并且指定我们想要终止的进程 PID。也可以用 jobspec（例如，“％1”）来代替 PID。

虽然这个命令看上去很直白， 但是它的含义不止于此。这个 kill 命令不是真的“杀死”程序，而是给程序 发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种。 在使用 Ctrl-c 和 Ctrl-z 的过程中我们已经看到信号的实际用法。当终端接受了其中一个按键组合后，它会给在前端运行 的程序发送一个信号。在使用 Ctrl-c 的情况下，会发送一个叫做 INT（Interrupt,中断）的信号；当使用 Ctrl-z 时，则发送一个叫做 TSTP（Terminal Stop,终端停止）的信号。程序，相应地，监听信号的到来，当程序 接到信号之后，则做出响应。一个程序能够监听和响应信号这件事允许一个程序做些事情， 比如，当程序接到一个终止信号时，它可以保存所做的工作。



### 通过 kill 命令给进程发送信号

如果在命令行中没有指定信号，那么默认情况下，发送 `TERM（Terminate，终止）`信号。kill 命令被经常 用来发送以下命令：

| 编号 | 名字 | 含义                                                         |
| :--- | :--- | :----------------------------------------------------------- |
| 1    | HUP  | 挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 |
| 2    | INT  | 中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。 |
| 9    | KILL | 杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。 |
| 15   | TERM | 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。 |
| 18   | CONT | 继续。在一个停止信号后，这个信号会恢复进程的运行。           |
| 19   | STOP | 停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。 |

| 编号 | 名字  | 含义                                                         |
| :--- | :---- | :----------------------------------------------------------- |
| 3    | QUIT  | 退出                                                         |
| 11   | SEGV  | 段错误(Segmentation Violation)。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。 |
| 20   | TSTP  | 终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。 |
| 28   | WINCH | 改变窗口大小(Window Change)。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 |

```sh
[me@linuxbox ~]$ xlogo &
[1] 13546
[me@linuxbox ~]$ kill -1 13546
[1]+ Hangup         xlogo
```

在这个例子里，我们在后台启动 xlogo 程序，然后通过 kill 命令，发送给它一个 HUP 信号。 这个 xlogo 程序终止运行，并且 shell 指示这个后台进程已经接受了一个挂起信号。在看到这条 信息之前，你可能需要多按几次 enter 键。注意，信号既可以用号码，也可以用名字来指定， 包括在前面加上字母 “SIG” 的名字。

```sh
[me@linuxbox ~]$ xlogo 1] 13601
[me@linuxbox ~]$ kill -INT 13601
[1]+ Interrupt                    xlogo
[me@linuxbox ~]$ xlogo &
[1] 13608
[me@linuxbox ~]$ kill -SIGINT 13608
[1]+ Interrupt                    xlogo
```



### 通过 killall 命令给多个进程发送信号

也有可能通过 killall 命令，给匹配特定程序或用户名的多个进程发送信号。下面是 killall 命令的语法形式：

```sh
killall [-u user] [-signal] name...
```

```sh
[me@linuxbox ~]$ xlogo &
[1] 18801
[me@linuxbox ~]$ xlogo &
[2] 18802
[me@linuxbox ~]$ killall xlogo
[1]- Terminated                xlogo
[2]+ Terminated                xlogo
```

记住，和 kill 命令一样，你必须拥有超级用户权限才能给不属于你的进程发送信号。



### 更多和进程相关的命令

| 命令名 | 命令描述                                                     |
| :----- | :----------------------------------------------------------- |
| pstree | 输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。 |
| vmstat | 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。 |
| xload  | 一个图形界面程序，可以画出系统负载随时间变化的图形。         |
| tload  | terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 |





## 14、软件包管理

不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。

| 包管理系统           | 发行版 (部分列表)                                            |
| :------------------- | :----------------------------------------------------------- |
| Debian Style (.deb)  | Debian, Ubuntu, Xandros, Linspire                            |
| Red Hat Style (.rpm) | Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS |



Linux 系统中几乎所有的软件都可以在互联网上找到。其中大多数软件由发行商以 包文件的形式提供，剩下的则以源码形式存在，可以手动安装。在后面章节里，我们将会谈谈怎样 通过编译源码来安装软件。



### 包文件

在包管理系统中软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。

软件包文件是由软件包维护者创建的，他通常是（但不总是）一名软件发行商的雇员。软件维护者 从上游提供商（程序作者）那里得到软件源码，然后编译源码，创建软件包元数据以及所需要的 安装脚本。通常，软件包维护者要把所做的修改应用到最初的源码当中，来提高此软件与 Linux 发行版其它部分的融合性。



### 资源库

虽然某些软件项目选择执行他们自己的打包和发布策略，但是现在大多数软件包是由发行商和感兴趣 的第三方创建的。系统发行版的用户可以在一个中心资源库中得到这些软件包，这个资源库可能 包含了成千上万个软件包，每一个软件包都是专门为这个系统发行版建立和维护的。

因软件开发生命周期不同阶段的需要，一个系统发行版可能维护着几个不同的资源库。例如，通常会 有一个”测试”资源库，其中包含刚刚建立的软件包，它们想要勇敢的用户来使用， 在这些软件包正式发布之前，让用户查找错误。系统发行版经常会有一个”开发”资源库， 这个资源库中保存着注定要包含到下一个主要版本中的半成品软件包。

一个系统发行版可能也会拥有相关第三方的资源库。这些资源库需要支持一些因法律原因， 比如说专利或者是 DRM 反规避问题，而不能被包含到发行版中的软件。可能最著名的案例就是 对加密DVD的播放支持，在美国这是不合法的。第三方资源库在一些软件专利和反规避法案不 生效的国家中设立并分发资源。这些资源库通常完全地独立于它们所支持的资源库，要想使用它们， 你必须了解它们，手动地把它们包含到软件包管理系统的配置文件中。



### 依赖性

程序很少独立工作；他们需要依靠其他程序的组件来完成他们的工作。程序所共有的活动，如输入/输出， 就是由一个被多个程序调用的子例程处理的。这些子例程存储在动态链接库中。动态链接库为多个程 序提供基本服务。如果一个软件包需要一些共享的资源，如一个动态链接库，它就被称作有一个依赖。 现代的软件包管理系统都提供了一些依赖项解析方法，以确保安装软件包时，其所有的依赖也被安装。



### 上层和底层软件包工具

软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。在这一章中，我们将看一下由 Debian 风格的系统 （比如说 Ubuntu，还有许多其它系统）提供的工具，还有那些由 Red Hat 产品使用的工具。虽然所有基于 Red Hat 风格的发行版都依赖于相同的底层程序（rpm）, 但是它们却使用不同的上层工具。在我们的讨论中，我们将研究Fedora, Red Hat 企业版，和 CentOs所使用的 yum 。其它Red Hat 风格的发行版提供了带有类似yum的其他上层工具。

| 发行版                                   | 底层工具 | 上层工具          |
| :--------------------------------------- | :------- | :---------------- |
| Debian-Style                             | dpkg     | apt-get, aptitude |
| Fedora, Red Hat Enterprise Linux, CentOS | rpm      | yum               |



### 常见软件包管理任务

通过命令行软件包管理工具可以完成许多操作。我们将会看一下最常用的工具。注意底层工具也 支持软件包文件的创建，这个话题超出了本书叙述的范围。在以下的讨论中，”package_name” 这个术语是指软件包实际名称，而不是指”package_file”，它是包含在软件包中的文件名。



### 查找资源库中的软件包

| 风格    | 命令                                           |
| :------ | :--------------------------------------------- |
| Debian  | apt-get update; apt-cache search search_string |
| Red Hat | yum search search_string                       |



```sh
yum search emacs
```



### 从资源库中安装一个软件包

上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。

| 风格    | 命令                                         |
| :------ | :------------------------------------------- |
| Debian  | apt-get update; apt-get install package_name |
| Red Hat | yum install package_name                     |



### 通过软件包文件来安装软件

如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | dpkg --install package_file |
| Red Hat | rpm -i package_file         |

```sh
rpm -i emacs-22.1-7.fc7-i386.rpm
```



### 卸载软件

可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | apt-get remove package_name |
| Red Hat | yum erase package_name      |

```sh
apt-get remove emacs
```





### 经过资源库来更新软件包

| 风格    | 命令                            |
| :------ | :------------------------------ |
| Debian  | apt-get update; apt-get upgrade |
| Red Hat | yum update                      |



### 经过软件包文件来升级软件

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | dpkg --install package_file |
| Red Hat | rpm -U package_file         |

```sh
rpm -U emacs-22.1-7.fc7-i386.rpm
```



### 列出所安装的软件包

| 风格    | 命令        |
| :------ | :---------- |
| Debian  | dpkg --list |
| Red Hat | rpm -qa     |



### 确定是否安装了一个软件包

| 风格    | 命令                       |
| :------ | :------------------------- |
| Debian  | dpkg --status package_name |
| Red Hat | rpm -q package_name        |

```sh
dpkg --status emacs
```



### 显示所安装软件包的信息

| 风格    | 命令                        |
| :------ | :-------------------------- |
| Debian  | apt-cache show package_name |
| Red Hat | yum info package_name       |



### 查找安装了某个文件的软件包

| 风格    | 命令                    |
| :------ | :---------------------- |
| Debian  | dpkg --search file_name |
| Red Hat | rpm -qf file_name       |



## 23、编译程序

在这一章中，我们将看一下如何通过编译源代码来创建程序。源代码的可用性是至关重要的自由，从而使得 Linux 成为可能。 整个 Linux 开发生态圈就是依赖于开发者之间的自由交流。对于许多桌面用户来说，编译是一种失传的艺术。以前很常见， 但现在，由系统发行版提供商维护巨大的预编译的二进制仓库，准备供用户下载和使用。在写这篇文章的时候， Debian 仓库（最大的发行版之一）包含了几乎23,000个预编译的包。

make - 维护程序的工具



### 什么是编译？

简而言之，编译就是把源码（一个由程序员编写的人类可读的程序的说明）翻译成计算机处理器的语言的过程。



### 编译一个 C 语言

让我们编译一些东西。在我们编译之前，然而我们需要一些工具，像编译器、链接器以及 make。 在 Linux 环境中，普遍使用的 C 编译器叫做 gcc（GNU C 编译器），最初由 Richard Stallman 写出来的。 大多数 Linux 系统发行版默认不安装 gcc。我们可以这样查看该编译器是否存在：

```sh
[me@linuxbox ~]$ which gcc
/usr/bin/gcc
```

在这个例子中的输出结果表明安装了 gcc 编译器。

为了我们的编译练习，我们将编译一个叫做 diction 的程序，来自 GNU 项目。这是一个小巧方便的程序， 检查文本文件的书写质量和样式。就程序而言，它相当小，且容易创建。

遵照惯例，首先我们要创建一个名为 src 的目录来存放我们的源码，然后使用 ftp 协议把源码下载下来。

```sh
[me@linuxbox ~]$ mkdir src
[me@linuxbox ~]$ cd src
[me@linuxbox src]$ ftp ftp.gnu.org
Connected to ftp.gnu.org.
220 GNU FTP server ready.
Name (ftp.gnu.org:me): anonymous
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd gnu/diction
250 Directory successfully changed.
ftp> ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
-rw-r--r-- 1 1003 65534 68940 Aug 28 1998 diction-0.7.tar.gz
-rw-r--r-- 1 1003 65534 90957 Mar 04 2002 diction-1.02.tar.gz
-rw-r--r-- 1 1003 65534 141062 Sep 17 2007 diction-1.11.tar.gz
226 Directory send OK.
ftp> get diction-1.11.tar.gz
local: diction-1.11.tar.gz remote: diction-1.11.tar.gz
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for diction-1.11.tar.gz
(141062 bytes).
226 File send OK.
141062 bytes received in 0.16 secs (847.4 kB/s)
ftp> bye
221 Goodbye.
[me@linuxbox src]$ ls
diction-1.11.tar.gz
```

注意：因为我们是这个源码的“维护者”，当我们编译它的时候，我们把它保存在 ~/src 目录下。 由你的系统发行版源码会把源码安装在 /usr/src 目录下，而供多个用户使用的源码，通常安装在 /usr/local/src 目录下。

正如我们所看到的，通常提供的源码形式是一个压缩的 tar 文件。有时候称为 tarball，这个文件包含源码树， 或者是组成源码的目录和文件的层次结构。当到达 ftp 站点之后，我们检查可用的 tar 文件列表，然后选择最新版本，下载。 使用 ftp 中的 get 命令，我们把文件从 ftp 服务器复制到本地机器。

一旦 tar 文件下载下来之后，必须解包。通过 tar 程序可以完成：

```sh
[me@linuxbox src]$ tar xzf diction-1.11.tar.gz
[me@linuxbox src]$ ls
diction-1.11
diction-1.11.tar.gz
```



### 检查源码树

打开该 tar 文件，会创建一个新的目录，名为 diction-1.11。这个目录包含了源码树。让我们看一下里面的内容：

```sh
[me@linuxbox src]$ cd diction-1.11
[me@linuxbox diction-1.11]$ ls
config.guess     diction.c          getopt.c      nl
config.h.in      diction.pot        getopt.h      nl.po
config.sub       diction.spec       getopt_int.h  README
configure        diction.spec.in    INSTALL       sentence.c
configure.in     diction.texi.in    install-sh    sentence.h
COPYING en       Makefile.in        style.1.in
de               en_GB              misc.c        style.c
de.po            en_GB.po           misc.h        test
diction.1.in     getopt1.c          NEWS
```



在源码树中，我们看到大量的文件。属于 GNU 项目的程序，还有其它许多程序都会，提供文档文件 README，INSTALL，NEWS，和 COPYING。

这些文件包含了程序描述，如何建立和安装它的信息，还有其它许可条款。在试图建立程序之前，仔细阅读 README 和 INSTALL 文件，总是一个不错的主意。

### 构建程序

大多数程序通过一个简单的，两个命令的序列构建：

```sh
./configure
make
```

这个 **configure** 程序是一个 shell 脚本，由源码树提供。它的工作是分析程序构建环境。大多数源码会设计为可移植的。 也就是说，它被设计成能够在不止一种类 Unix 系统中进行构建。但是为了做到这一点，在建立程序期间，为了适应系统之间的差异， 源码可能需要经过轻微的调整。configure 也会检查是否安装了必要的外部工具和组件。让我们运行 configure 命令。 因为 configure 命令所在的位置不是位于 shell 通常期望程序所呆的地方，我们必须明确地告诉 shell 它的位置，通过 在命令之前加上 ./ 字符，来表明程序位于当前工作目录：

```sh
[me@linuxbox diction-1.11]$ ./configure
```

configure 将会输出许多信息，随着它测试和配置整个构建过程。当结束后，输出结果看起来像这样：

```sh
checking libintl.h presence... yes
checking for libintl.h... yes
checking for library containing gettext... none required
configure: creating ./config.status
config.status: creating Makefile
config.status: creating diction.1
config.status: creating diction.texi
config.status: creating diction.spec
config.status: creating style.1
config.status: creating test/rundiction
config.status: creating config.h
[me@linuxbox diction-1.11]$
```

这里最重要的事情是没有错误信息。如果有错误信息，整个配置过程失败，然后程序不能构建直到修正了错误

我们看到在我们的源码目录中 configure 命令创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。没有它，make 程序就不能运行。Makefile 是一个普通文本文件，所以我们能查看它：

```sh
[me@linuxbox diction-1.11]$ less Makefile
```

这个 make 程序把一个 makefile 文件作为输入（通常命名为 Makefile），makefile 文件 描述了包括最终完成的程序的各组件之间的关系和依赖性。

```sh
[me@linuxbox diction-1.11]$ make
```

当 make 程序运行结束后，现在我们将看到所有的目标文件出现在我们的目录中。

在这些文件之中，我们看到 diction 和 style，我们开始要构建的程序。恭喜一切正常！我们刚才源码编译了 我们的第一个程序。但是出于好奇，让我们再运行一次 make 程序：

```sh
[me@linuxbox diction-1.11]$ make
make: Nothing to be done for `all'.
```

它只是产生这样一条奇怪的信息。怎么了？为什么它没有重新构建程序呢？啊，这就是 make 奇妙之处了。make 只是构建 需要构建的部分，而不是简单地重新构建所有的内容。由于所有的目标文件都存在，make 确定没有任何事情需要做。



### 安装程序

打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 `/usr/local/bin`，为在本地所构建软件的传统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户， 来执行安装操作：

```sh
[me@linuxbox diction-1.11]$ sudo make install
```

执行了安装后，我们可以检查下程序是否已经可用：

```sh
[me@linuxbox diction-1.11]$ which diction
/usr/local/bin/diction
[me@linuxbox diction-1.11]$ man diction
```